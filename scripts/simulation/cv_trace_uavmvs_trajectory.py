import os
import time
import argparse

import ff
import numpy as np
import airsim

from airsim import Pose, Vector3r, Quaternionr
from ff.types import to_xyz_str
from ie.airsimy import connect, AirSimImage

try:
    from include_in_path import FF_PROJECT_ROOT, include

    include(FF_PROJECT_ROOT, "misc", "tools", "uavmvs_parse_traj")
    from uavmvs_parse_traj import TrajectoryCameraKind, parse_uavmvs
except:
    raise

###############################################################################
## preflight (called before connecting) #######################################
###############################################################################


def preflight(args: argparse.Namespace) -> None:
    _, ext = os.path.splitext(args.trajectory_path)
    assert os.path.isfile(args.trajectory_path), f"Invalid file path: '{args.trajectory_path}'"
    assert ext in parse_uavmvs.keys(), f"Invalid trajectory extension: '{args.trajectory_path}'"

    args.trajectory = parse_uavmvs[ext](args.trajectory_path)
    if args.verbose:
        ff.log(f"The trajectory has {len(args.trajectory)} camera poses")

    if args.capture_dir:
        assert os.path.isdir(args.capture_dir)

    if args.env_name is not None:
        # the --launch option was passed
        ff.launch_env(*ff.LaunchEnvArgs(args))
        ff.input_or_exit("\nPress [enter] to connect to AirSim ")


###############################################################################
## fly (called after connecting) ##############################################
###############################################################################


def fly(client: airsim.MultirotorClient, args: argparse.Namespace) -> None:
    initial_pose = client.simGetVehiclePose()

    if args.verbose:
        ff.print_pose(initial_pose, airsim.to_eularian_angles)

    if args.flush:
        client.simFlushPersistentMarkers()

    def from_numpy(vector):
        assert vector.shape == (3,)
        vector[1] *= -1.0
        vector[2] *= -1.0
        if args.offset is None:
            return Vector3r(*map(float, vector))
        else:
            return Vector3r(*map(float, vector)) + Vector3r(*args.offset)

    assert all([camera.kind == TrajectoryCameraKind.Traj for camera in args.trajectory])
    camera_poses = [
        Pose(
            from_numpy(camera.position) + Vector3r(0, 0, -1),
            (Quaternionr(*map(float, camera.into(TrajectoryCameraKind.Csv).rotation))),
        )
        for camera in args.trajectory
    ]

    for i, pose in enumerate(camera_poses):
        p = pose.position
        if not args.capture_dir:
            ff.log(f"Going to {to_xyz_str(p)}")
        # client.moveToPositionAsync(p.x_val, p.y_val, p.z_val, velocity=2).join()
        client.simSetVehiclePose(pose, ignore_collison=True)
        time.sleep(1)
        if args.capture_dir:
            png = AirSimImage.get_mono(client, ff.CameraName.bottom_center)
            # (response,) = client.simGetImages(
            #     [
            #         airsim.ImageRequest(
            #             ff.CameraName.bottom_center, airsim.ImageType.Scene, False, False
            #         )
            #     ]
            # )
            # png = np.flipud(
            #     np.fromstring(response.image_data_uint8, dtype=np.uint8).reshape(
            #         response.height, response.width, 3
            #     )
            # )
            name = os.path.join(
                args.capture_dir, f"pose_{i}.png"  # TODO use argparse to add prefix / suffix
            )
            airsim.write_png(name, png)
            ff.log(f"Saving image to '{name}' at {to_xyz_str(p)}")
        time.sleep(0.5)


###############################################################################
## main #######################################################################
###############################################################################


def main(args: argparse.Namespace) -> None:
    if args.verbose:
        ff.print_airsim_path(airsim.__path__)

    preflight(args)  # setup
    client = connect(ff.SimMode.ComputerVision)
    try:
        fly(client, args)  # do stuff
    except KeyboardInterrupt:
        client.reset()  # avoid UE4 'fatal error' when exiting with Ctrl+C
    finally:
        ff.log("Done")


###############################################################################
## argument parsing ###########################################################
###############################################################################


def get_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description="Follow a trajectory generated by uavmvs in AirSim's CV mode."
    )

    parser.add_argument("trajectory_path", type=str, help="Path to a .TRAJ, .CSV or .UTJ file")

    parser.add_argument("--capture_dir", type=str, help="Folder where image captures will be saved")
    parser.add_argument("--flush", action="store_true", help="Flush old plots")

    parser.add_argument(
        "--offset",
        type=float,
        nargs=3,
        metavar=("X", "Y", "Z"),
        help="Offset added to all points  (e.g. --offset -55 11 1)",
    )

    ff.add_arguments_to(parser)
    return parser


if __name__ == "__main__":
    parser = get_parser()
    args = parser.parse_args()

    main(args)
